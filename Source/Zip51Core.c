/**********************************************************************************************************************
														zip51
												适合于在51芯片上的实时内核
												作者：孤独剑
												时间：2010 10  24
												包含本工程所有与内核管理有关的函数
文件名：				zip51_core.c
函数个数：				7
需要用户修改的个数：	无
**********************************************************************************************************************/

#ifndef  ZIP51_FILE
#define  OS_GLOBALS
#include "includes.h"
#endif


byte				code		Prio_RdyTable[4]			= {0x08,0x04,0x02,0x01};							//优先级到就绪表
byte				code		RdyTable_Prio[16]			= {0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
///就绪表到优先级






/*********************************************************************************************************
函数名		：	SchedLock
描述		：	任务调度锁 调用该函数之后任务则不会调度   当一段代码可以被中断打断但不可以被切换到其他任务
 				的时候可以使用该函数保护 再用SchedUnLock函数打开任务调度
参数 		：	无
返回值		：	无
注意		：	调用该函数之后绝对不可以在调用任何可以使任务等待的函数
				你可能会想当一个任务的一段代码 等待一个事件 在等待过程中又不想让其它的任务运行干扰到这段代码
				于是调用这个函数先锁定调度器，然后再等待以为这样会直接得到了事件通知
				其实如果这样做将导致一个错误的结果因为调度器被锁定任何调用等待的函数都不会等待而是直接返回
				这样调用该函数的任务会认为自己等待超时 （而实际上该任务并没有等待）
				调用多少次SchedLock就应该相应的调用多少次SchedUnLock 才会解锁调度器
				最多支持255层锁定
*********************************************************************************************************/
#if				SCHED_LOCK_EN
void			SchedLock (void)
{
		if (OSRunning )
		{
				ENTER_CRITICAL();
				if (gLockNest < 255 )
				{
						gLockNest	++;
				}
				EXIT_CRITICAL();
		}	
}
#endif



/*********************************************************************************************************
函数名		：	SchedUnLock
描述		：	任务调度解锁  调用SchedLock之后唯一能将任务调度解锁的函数
参数 		：	无
返回值		：	无
注意		：	无
*********************************************************************************************************/
#if				SCHED_LOCK_EN
void			SchedUnLock(void) small
{
		if (OSRunning )
		{
				ENTER_CRITICAL();
				if (gLockNest > 0 )
				{
						gLockNest	--;
						if ( (gIntNest					 == 0) && (gLockNest					 == 0) )
						{
								EXIT_CRITICAL();
								OSSched ();
						}
						else
						{
								EXIT_CRITICAL();
						}
				}
				else
				{
						EXIT_CRITICAL();	
				}

		}
}
#endif



/*********************************************************************************************************
函数名		：	TimeTick
描述		：	系统每隔1ms会来到这里将每一个任务的睡眠时间减一
参数 		：	无
返回值		：	无
注意		：	无
*********************************************************************************************************/
void			TimeTick (void )  small
{
		byte		i;
		
		#if			TIME_CNT_EN
		ENTER_CRITICAL();
		TimeCnt	++;
		EXIT_CRITICAL();
		#endif
		
		if ( OSRunning )
		{
				ENTER_CRITICAL();
				for (i = 0;i <= 3;i ++ )
				{
						if (gTCB[i].TimeDly )
						{
								if (-- gTCB[i].TimeDly 	== 0 )
								{
										if ( (gTCB[i].TaskStat & TASK_SUSPEND) 	== 0 )
										{
												RdyTable		|=	Prio_RdyTable[i];
										}
										else
										{
												gTCB[i].TimeDly		= 1;
										}
								}
						}
				}
				EXIT_CRITICAL();
		}
}



/*********************************************************************************************************
函数名		：	OSSched
描述		：	任务调度器  判断当前就绪了的最高优先级任务是否与当前任务优先级相同如果不相同则开启任务调度
参数 		：	无
返回值		：	无
注意		：	当任务调度被锁定，或者是在中断中调用则这个函数什么也不做直接返回
				这个函数为zip51系统调用			
*********************************************************************************************************/
void			OSSched (void )  small
{
		ENTER_CRITICAL();
		if ( (gIntNest	== 0) && (gLockNest	== 0 ) )
		{	 	
				gSysPriHighRdy		= RdyTable_Prio[RdyTable];
				if (gSysPriHighRdy	!= gSysPriCur	 )												///当前就绪的最高优先级 与当前运行任务优先级不同
				{
						TaskSw ();																	///调用这句时用LCALL（假设是代码存储器选择的大型）
				}
		}
		EXIT_CRITICAL();
}


/*********************************************************************************************************
函数名		：	OsInit
描述		：	系统全局变量初始化，系统定时器初始化
参数 		：	无
返回值		：	无
注意		：	在这个函数中初始化定时器之后还不可以启用，一直到OSStart时才可以开启定时器否则系统有可能
				无法正常启动
				为系统调用	 一般来说用户初始化代码可以放在任务中完成		
*********************************************************************************************************/
void			OsInit (void )  small
{
		#if		MBOX_EN
		byte	i;
		#endif

		OSRunning					= 0;
		gIntNest					= 0;
		gLockNest					= 0;
		RdyTable					= 0;

		#if							TIME_CNT_EN
		TimeCnt						= 0;
		#endif
		#if							IDLE_CNT_EN
		IdleCnt						= 0;
		#endif


		OSIntInit();

		#if							SEM_EN
		/*************************************
		            初始化信号量
		*************************************/
		gWaitSem[0]		= gWaitSem[1]	= 0;
		gSem[0]			= gSem[1]		= 0;
		#endif

		#if							MUTEX_EN
		/*************************************
		            初始化互斥体
		*************************************/
		gMutex			= 0;
		gWaitMutex[0]	= gWaitMutex[1]	= gWaitMutex[2]	= gWaitMutex[3]	= 0;
		#endif

		#if							MBOX_EN
		/*************************************
		            初始化消息盒子
		*************************************/
		for (i = 0;i < MBOX_NUM;i ++ )
		{
				gMBox[i]	= gWaitMBox[i]	= 0;
		}
		#endif


		#if							MESS_Q_EN
		/*************************************
		            初始化消息队列
		*************************************/
		QCreate ();
		#endif
}


/*********************************************************************************************************
函数名		：	IntEnter
描述		：	每一个中断开始时都应该调用该函数 保存相关的堆栈指针和寄存器变量
参数 		：	无
返回值		：	无
注意		：	用户每一个中断开始时都应该 调用该函数 在这个函数内部刚开始关中断然后执行所有代码再开中断
*********************************************************************************************************/
void			IntEnter (void )small 
{
		ENTER_CRITICAL();
		gIntNest	++;
		EXIT_CRITICAL();
}



/*********************************************************************************************************
函数名		：	IntExit
描述		：	每一个中断结束时都应该调用该函数 通过判断是否有应该切换任务调用IntSw（）
参数 		：	无
返回值		：	无
注意		：	用户每一个中断结束时都应该 调用该函数 在这个函数内部刚开始关中断然后执行所有代码再开中断
				发生了一个中断导致内核中事件情况改变，所以在中断退出时应该检验是否要切换任务
*********************************************************************************************************/
void			IntExit (void )  small
{
		ENTER_CRITICAL();
		if ( OSRunning )
		{
				if (gIntNest )
				{
						gIntNest -- ;
				}
				if ( (gIntNest	== 0) && (gLockNest	 == 0 ) )
				{	 	
						gSysPriHighRdy							= RdyTable_Prio[RdyTable] & 0x0F ;
						if (gSysPriHighRdy						!= gSysPriCur					 )
						{
								IntSw ();						///中断中任务切换
						}
				}
		}
		EXIT_CRITICAL();
}















